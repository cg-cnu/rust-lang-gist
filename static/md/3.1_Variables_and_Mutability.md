class: middle, center

### 3.1

# Variables and Mutability

---

class: left

# Variables

Variables are declared using **let**

```rust
fn main() {
  let x = 5;
  println!("The value of x is: {}", x);
}
```

```rust
The value of x is: 5
```

---

class: left

# Constants

Constants are declared using **const**

```rust
fn main() {
  const PUPPY_COUNT: i32 = 5;
  println!("The total no of puppies are: {}", PUPPY_COUNT);
}
```

```rust
The total no of puppies are: 5
```

- Valid for the entire run of the program in the defined scope

- While Rust can infer types for variables, you need to annotate for constants

**convention:** Snake_case with CAPITAL_LETTERS

---

class: left

# Immutable Variables

Variables are **immutable by default**, means you can't change them

```rust
fn main() {
  let x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is: {}", x);
}
```

```rust
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

---

class: left

# Mutable Variables

Add **mut** keyword to make them mutable

```rust
fn main() {
  let mut x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is: {}", x);
}
```

```rust
The value of x is: 5
The value of x is: 6
```

`mut` will let you change the value not the type

---

class: left

# Constants vs Immutable

- Constants aren’t only immutable by default, they’re always immutable

- Can't assign functions to a const

- Can't use if expressions with const

- `mut` is not valid with `constants`

---

class: left

# Shadowing

```rust
fn main() {
  let x = "test";

  let x = 4;

  let x = x * 2;

  println!("The value of x is: {}", x);
}
```

When declaring a new variable using `let` with the same name as the old variable,
the new variable is shadowing the old one

- It helps perform transformations on immutable variables

- It effectively creates a new variable with the same name

---

class: left

# Mutable vs Shadowing

- `mut` changes the value where as `shadowing` creates a new variable

- `mut` will only change the value not the type

- `shadowing` gives the flexibility of changing the type of the variable

```rust
let spaces = "   "; // type of String
let spaces = spaces.len(); // type of integer
```

---

class: left

# Summary

- `let` declares a variable

- `mut` makes it mutable

- `const` declares a constant

- `const` can't be mutable

- declaring a variable again with `let` is called shadowing

- `shadowing` effectively creates new variable
